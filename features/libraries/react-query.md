---
description: React Query is often described as the missing data-fetching library for React.
---

# React Query

## Introduction

Data fetching throughout the storefront-app is handled by React Query fetching, synchronising and updating server state.

* React Query handles all data fetching and sending for storefront-app in a predictable way.
* The library provides a React Hook for this [useQuery](https://react-query-beta.tanstack.com/reference/useQuery)&#x20;
* Storefront-app GraphQL queries have automatically generated hooks for each GraphQL query. These hooks are wrappers for useQuery. For example useGetProductsQuery and return the same API
* React Queries hook provides an out of the box way to deal with query state, for example

```typescript
function Todos() {
  const { isLoading, isError, data, error } = useQuery('todos', fetchTodoList)

  if (isLoading) {
    return <span>Loading...</span>
  }

  if (isError) {
    return <span>Error: {error.message}</span>
  }

  // We can assume by this point that `isSuccess === true`
    return (
    <ul>
      {data.map(todo => (
          <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}
```

## Usage in storefront-app

### Typical Usage

To help us to take advantage of both our generated GraphQL hooks (see GraphQL Codegen), make use of React Queries internal cache and allow the Query Client to use data generated during SSG, our typical code looks like this.

```typescript
const { data, isError ,isLoading } = useQuery(
    useGetProductQuery.getKey(variables),
    useGetProductQuery.fetcher(storefrontQueryDataSource, variables)
);
```

Here `useQuery` accepts 2 arguments.&#x20;

* A query key, a string array used to match the query
* A promise used to return the data

Both of these arguments are provided by helper functions created and exposed from GraphQL Codegen.&#x20;

### The Fetcher

As can be seen in the example above hooks generated by GraphQL Codegen expose the fetcher function. (see fetcher)\
\
The fetcher is a wrapper for a fetch based promise returning data from our GraphQL query/mutation. It accepts 2 variables.

* `dataSource` an object containing the URL endpoint for the query and fetchParams which allow us to adjust the [request parameters](https://microsoft.github.io/PowerBI-JavaScript/interfaces/\_node\_modules\_typedoc\_node\_modules\_typescript\_lib\_lib\_dom\_d\_.requestinit.html) for our fetch query.
* `variables` the variables required by our GraphQL query (if required)

URL dataSource objects are provided by the helper script [datasources.md](../scripts/datasources.md "mention")which providers a single location for the import of enviromental variables.

## Further Reading

* [Quick Start](https://react-query.tanstack.com/quick-start)
* [Devtools](https://react-query.tanstack.com/devtools)
* [SSR Next.js](https://react-query.tanstack.com/guides/ssr#using-nextjs)

## Technical Details

* React Query Client is included throughout the application through the [app-provider.md](../../components/default-components/app-provider.md "mention") component.
* [Static Site Generation](https://nextjs.org/docs/basic-features/data-fetching/get-static-props) content can make use of React Query via [queryClient.prefetchQuery](https://react-query-beta.tanstack.com/reference/QueryClient#queryclientprefetchquery)
*   In order to make use of React Queries internal cache and to allow the Query Client to use data generated during SSG our queries typically use 2 arguments.

    *

